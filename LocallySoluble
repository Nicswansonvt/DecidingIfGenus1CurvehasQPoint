/*
    Input: A multi or univariate polynomial f defined over Q.
    Output: The least common multiple of the denominators of the coefficients of f.
*/
ProductOfDenominators := function(f)
    if f eq 0 then
        return 0;
    end if;
    denoms := [];
    for c in Coefficients(f) do
        denoms := Append(denoms, Denominator(c));
    end for;
    return LCM(denoms);
end function;

/*
    Input: A Crv C defined over Q.
    Output: A projective plane curve C' defined over Q and a map proj such that proj is an isomorphism from C to C' away from the singular points of C'.
*/
SingularPlaneModel := function(C)
    if IsAffine(C) then
        C := ProjectiveClosure(C);
    end if;
    Cnew := C;
    map := IdentityMap(Ambient(C));
    while IsPlaneCurve(Cnew) eq false do
        p := [1];
        for i in [1..Dimension(Ambient(Cnew))] do
            p := Append(p, 0);
        end for;
        p := Ambient(Cnew) ! p;
        if p in Cnew then
            return true;
        end if;
        Cnew, mapnew := Projection(Cnew);
        map := map * mapnew;
    end while;
    return Cnew, Restriction(map, C, Cnew);
end function;

/*
    Input: A sequence of univariate polynomials of length at least 2. An integer, whos sign tells whether or not to evaluate the sequence at plus or minus infinity.
    Output: The number of sign variations in the sequence.
*/
SignVariations := function(polyseq, sign)
    valuations := [];
    for poly in polyseq do
        if poly eq 0 then
            continue;
        elif sign gt 0 then
            valuations := Append(valuations, LeadingCoefficient(poly));
        else
            if IsOdd(Degree(poly)) then
                valuations := Append(valuations, -LeadingCoefficient(poly));
            else
                valuations := Append(valuations, LeadingCoefficient(poly));
            end if;
        end if;
    end for;

    changes := 0;
    for i in [1..#valuations-1] do
        if valuations[i] * valuations[i + 1] lt 0 then
            changes := changes + 1;
        end if;
    end for;
    return changes;
end function;

/*
    Input: An irreducible univariate polynomial f.
    Output: true if f(x) = 0 has a root in the real numbers. false otherwise.
*/
HasRealRoot := function(f)
    if Degree(f) eq 0 then
        return f eq 0;
    end if;
    if IsOdd(Degree(f)) then
        return true;
    end if;

    fi := f;
    fi1 := Derivative(f);
    remainders := [fi, fi1];
    while fi1 ne 0 and Degree(fi1) ne 0 do
        r := -(fi mod fi1);
        remainders := Append(remainders, r);
        fi := fi1;
        fi1 := r;
    end while;

    return SignVariations(remainders, -1) - SignVariations(remainders, 1) gt 0;
end function;

/*
    Input: An irreducible bivariate polynomial f.
    Output: true if f(x, y) = 0 has a solution in the real numbers. false otherwise.
*/
HasRealSolution := function(f)
    P<x, y> := PolynomialRing(Rationals(), 2);
    f := P ! f;
    n := Degree(f);

    if n eq 0 then
        return f eq 0;
    end if;
    if Degree(f, y) eq 0 then
        f := Evaluate(f, [y, x]);
    end if;

    fn := P ! 0;
    for term in Terms(f) do
        if Degree(term) eq n then
            fn := fn + term;
        end if;
    end for;

    g := y * Derivative(f, x) - x * Derivative(f, y);
    c := 1;
    while GCD(f, g) ne 1 do
        g := y * Derivative(f, x) - (x - c) * Derivative(f, y);
        c := c + 1;
    end while;
    h := UnivariatePolynomial(Resultant(f, g, y));
    k := Parent(h) ! UnivariatePolynomial(Resultant(f, g, x));
    h := h div GCD(h, Derivative(h));
    k := k div GCD(k, Derivative(k));

    D := Discriminant(h) * (1 / Discriminant(k));
    m := 1;
    while Evaluate(fn, [m, 1]) eq 0 or Numerator(D) mod m eq 0 do
        m := m + 1;
    end while;

    H := Resultant(Evaluate(f, [m*(x + y), y]), Evaluate(g, [m*(x + y), y]), y);
    H := UnivariatePolynomial(H);

    return HasRealRoot(H);
end function;

/*
    Input: An irreducible bivariate polynomial f with integral coefficients and positive degree in both variables.
    Output: An integer analagous to the discriminant such that all primes dividing the integer are where C:f(x, y) = 0 might have bad reduction.
*/
BadPrimeDetector := function(f)
    P<x, y> := PolynomialRing(Rationals(), 2);
    UPR<z> := PolynomialRing(Integers());
    f := P ! f;
    h := UPR ! UnivariatePolynomial(Resultant(f, Derivative(f, x), y));
    k := UPR ! UnivariatePolynomial(Resultant(f, Derivative(f, y), y)); 
    G := GCD(h, k);
    c := GCD(Coefficients(G));
    A := h div G;
    B := k div G;
    A := A div GCD(A, Derivative(A));
    B := B div GCD(B, Derivative(B));
    return c * Resultant(A, B);
end function;

/*
    Input: An irreducible bivariate polynomial f with integral coefficients. A set of primes of potentially bad reduction.
    Output: A set of primes such that f is gaurenteed to have bad reduction at said primes and non others.
*/
PruneBadPrimes := function(f, S)
    C := Curve(AffineSpace(AlgebraicClosure(Rationals()), 2), [f]);
    p := 2;
    BadPrimes := [];
    for p in S do
        fp := PolynomialRing(AlgebraicClosure(GF(p)), 2) ! f;
        if Degree(fp) ne 0 then
            Cp := Curve(AffineSpace(CoefficientRing(Parent(fp)), 2), [fp]);
            if #SingularPoints(Cp) gt #SingularPoints(C) then
                BadPrimes := Append(BadPrimes, p);
            end if;
        else
            if fp eq 0 then
                BadPrimes := Append(BadPrimes, p);
            end if;
        end if;
    end for;
    return Set(BadPrimes);
end function;

/*
    Input: An irreducible bivariate polynomial f with integral coefficients.
    Output: A set a primes S, such that f has a solution mod p for all primes outside of S.
*/
BadPrimes := function(f)
    Rx := BadPrimeDetector(f);
    Ry := BadPrimeDetector(Evaluate(f, [Parent(f).2, Parent(f).1]));
    //This is the set of potentially bad primes of f.
    potentially_bad_primes := Set(PrimeDivisors(Rx)) join Set(PrimeDivisors(Ry));
    return PruneBadPrimes(potentially_bad_primes);
end function;

/*
    Input: An irreducible bivariate polynomial f(x, y) of nonzero x and y degree. A prime p.
    Output: True if f has a point in Zp and False otherwise.
*/
HasPointOverPrime := function(f, p)
    //Determining if f has a padic singular point can be done using exact padic fields in up to date versions of magma.
    P<x, y> := PolynomialRing(Integers(), 2);
    f := P ! f;
    pAdicPR := PolynomialRing(pAdicField(p));
    h := pAdicPR ! UnivariatePolynomial(Resultant(Derivative(f, x), Derivative(f, y), y));
    k := pAdicPR ! UnivariatePolynomial(Resultant(Derivative(f, x), Derivative(f, y), x));
    A := Roots(h);
    B := Roots(k);
    for a in A do
        for b in B do
            //This should be IsDefinitelyEqual() in the current version of magma.
            if Evaluate(PolynomialRing(pAdicField(p), 2) ! f, [a[1], b[1]]) eq 0 then
                return true;
            end if;
        end for;
    end for;

    //At this point we gaurentee f has no singularities and the while loop will terminate.
    //This is clearly the bottleneck of the locally soluble algorithm.
    i := 1;
    while true do
        is_empty := true;
        for a, b in [0..p^i - 1] do
            if Evaluate(f, [a, b]) mod p^i eq 0 then
                is_empty := false;
                if Evaluate(Derivative(f, x), [a, b]) mod p^i ne 0 or Evaluate(Derivative(f, y), [a, b]) mod p^i ne 0 then
                    return true;
                end if;
            end if;
        end for;
        if is_empty then
            return false;
        end if;
        i +:= 1;
    end while;
end function;

/*
    Input: A Crv C defined over Q.
    Output: true if C(Qp) has a point for all padic numbers. false otherwise.
*/
IsLocallySoluble := function(C)
    C := SingularPlaneModel(C);
    if #SingularPoints(C) gt 0 or [0, 0, 1] in C then
        return true;
    end if;
    F := DefiningPolynomial(C);
    if Coefficients(F) subset Integers() eq false then
        F := ProductOfDenominators(F) * F;
    end if;
    P<x, y> := PolynomialRing(Rationals(), 2);
    affine_patches := [
        Evaluate(F, [1, x, y]),
        Evaluate(F, [x, 1, y]),
        Evaluate(F, [x, y, 1])
    ];
    
    if HasRealSolution(affine_patches[1]) eq false or HasRealSolution(affine_patches[2]) eq false then
        return false;
    end if;

    S := BadPrimes(affine_patches[1]) join BadPrimes(affine_patches[2]) join BadPrimes(affine_patches[3]);
    d := Degree(F);
    s := #SingularPoints(Curve(ProjectiveSpace(AlgebraicClosure(), 2), [PolynomialRing(AlgebraicClosure(), 3) ! F]));
    B := (2*s - 2 + (d - 1)^2*(d - 2)^2 + (d - 1)*(d - 2)*Sqrt(4*s + (d - 1)^2*(d - 2)^2 - 4) ) / 2;
    S := S join Set(PrimesUpTo(Ceiling(B)));

    for p in S do
        has_point := false;
        for f in affine_patches do
            if HasPointOverPrime(f, p) eq true then
                has_point := true;
                break;
            end if;
        end for;
        if has_point eq false then
            return false;
        end if;
    end for;

    return true;
end function;

BadPrimeComputer := function(f)
    PR := Parent(f);
    x := PR.1;
    y := PR.2;
    h := UnivariatePolynomial(Resultant(f, Derivative(f, x), y));
    UPR := Parent(h);
    k := UPR ! UnivariatePolynomial(Resultant(f, Derivative(f, y), y)); 
    gcd := GCD(h, k);
    a := UPR ! (h div gcd);
    b := UPR ! (k div gcd);
    R := Resultant(a, b);
    factorization := PrimeDivisors(Integers() ! Numerator(R));
    return factorization;
end function;

RandomTest := function(d, S: RandomBound := 9)
    P := ProjectivePlane(Rationals());
    C := RandomPlaneCurve(d, S, P: RandomBound := RandomBound);
    f := CurveToIntegralPolynomial(AffinePatch(C, 1));
    computed_bad_primes := BadPrimeComputer(f);
    real_bad_primes := BadPrimesForReal(f, 1000);
    if real_bad_primes notsubset computed_bad_primes then
        printf "%o\n%o\n%o\n\n When x and y switched:\n", f, computed_bad_primes, real_bad_primes;
        printf "%o\n", BadPrimeComputer(Evaluate(f, [Parent(f).2, Parent(f).1]));
        return f;
    end if;
    return true;
end function;

ManyTests := function(NumTests, d, S)
    for i in [1..NumTests] do
        printf "Test number %o \n", i ;
        v := RandomTest(d, S);
        if v ne true then
            printf "Failed\n";
            return false;
            break;
        end if;
        printf "Passed\n";
    end for;
    return true;
end function;
