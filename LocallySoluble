/*
    Input: A Crv C defined over Q.
    Output: A projective plane curve C' defined over Q and a map proj such that proj is an isomorphism from C to C' away from the singular points of C'.
*/
SingularPlaneModel := function(C)
    if IsAffine(C) then
        C := ProjectiveClosure(C);
    end if;
    Cnew := C;
    map := IdentityMap(Ambient(C));
    while IsPlaneCurve(Cnew) eq false do
        p := [1];
        for i in [1..Dimension(Ambient(Cnew))] do
            p := Append(p, 0);
        end for;
        p := Ambient(Cnew) ! p;
        if p in Cnew then
            return true;
        end if;
        Cnew, mapnew := Projection(Cnew);
        map := map * mapnew;
    end while;
    return Cnew, Restriction(map, C, Cnew);
end function;



/*
    Input: A Crv C defined over Q.
    Output: true if C(Qp) has a point for all padic numbers. false otherwise.
*/
IsLocallySoluble := function(C)
    C := SingularPlaneModel(C);
    if #SingularPoints(C) gt 0 or [0, 0, 1] in C then
        return true;
    end if;
    D1 := AffinePatch(C, 1);
    D2 := AffinePatch(C, 2);
    D3 := AffinePatch(C, 3);
    
end function;

PolynomialMakeIntergal := function(f)
    denom := [];
    for coeff in Coefficients(f) do
        denom := Append(denom, Denominator(coeff));
    end for;
    denom := LCM(denom);
    return f * denom;
end function;

CurveToIntegralPolynomial := function(C)
    return PolynomialMakeIntergal(DefiningPolynomial(C));
end function;

BadPrimeComputer := function(f)
    PR := Parent(f);
    x := PR.1;
    y := PR.2;
    h := UnivariatePolynomial(Resultant(f, Derivative(f, x), y));
    UPR := Parent(h);
    k := UPR ! UnivariatePolynomial(Resultant(f, Derivative(f, y), y)); 
    gcd := GCD(h, k);
    a := UPR ! (h div gcd);
    b := UPR ! (k div gcd);
    R := Resultant(a, b);
    factorization := PrimeDivisors(Integers() ! Numerator(R));
    return factorization;
end function;

BadPrimesForReal := function(f, range)
    C := Curve(AffineSpace(AlgebraicClosure(Rationals()), 2), [f]);
    p := 2;
    BadPrimes := [];
    for i in [1..range] do
        fp := PolynomialRing(GF(p), 2) ! f;
        if Degree(fp) ne 0 then
            Cp := Curve(AffineSpace(CoefficientRing(Parent(fp)), 2), [fp]);
            if #SingularPoints(Cp) gt #SingularPoints(C) then
                BadPrimes := Append(BadPrimes, p);
            end if;
        else
            if fp eq 0 then
                BadPrimes := Append(BadPrimes, p);
            end if;
        end if;
        p := NextPrime(p);
    end for;
    return BadPrimes;
end function;

RandomTest := function(d, S: RandomBound := 9)
    P := ProjectivePlane(Rationals());
    C := RandomPlaneCurve(d, S, P: RandomBound := RandomBound);
    f := CurveToIntegralPolynomial(AffinePatch(C, 1));
    computed_bad_primes := BadPrimeComputer(f);
    real_bad_primes := BadPrimesForReal(f, 1000);
    if real_bad_primes notsubset computed_bad_primes then
        printf "%o\n%o\n%o\n\n When x and y switched:\n", f, computed_bad_primes, real_bad_primes;
        printf "%o\n", BadPrimeComputer(Evaluate(f, [Parent(f).2, Parent(f).1]));
        return f;
    end if;
    return true;
end function;

ManyTests := function(NumTests, d, S)
    for i in [1..NumTests] do
        printf "Test number %o \n", i ;
        v := RandomTest(d, S);
        if v ne true then
            printf "Failed\n";
            return false;
            break;
        end if;
        printf "Passed\n";
    end for;
    return true;
end function;
