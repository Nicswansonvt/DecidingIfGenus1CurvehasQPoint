PolynomialMakeIntergal := function(f)
    denom := [];
    for coeff in Coefficients(f) do
        denom := Append(denom, Denominator(coeff));
    end for;
    denom := LCM(denom);
    return f * denom;
end function;

CurveToIntegralPolynomial := function(C)
    return PolynomialMakeIntergal(f);
end function;

BadPrimeComputer := function(f)
    PR := Parent(f);
    x := PR.1;
    y := PR.2;
    h := UnivariatePolynomial(Resultant(f, Derivative(f, x), y));
    UPR := Parent(h);
    k := UPR ! UnivariatePolynomial(Resultant(f, Derivative(f, y), y)); 
    gcd := GCD(h, k);
    a := UPR ! (h div gcd);
    b := UPR ! (k div gcd);
    R := Resultant(a, b);
    factorization := Factorisation(Integers() ! Numerator(R));
    return factorization;
end function;

BadPrimesForReal := function(f, range)
    C := Curve(AffineSpace(CoefficientRing(Parent(f)), 2), f);
    p := 2;
    BadPrimes := [];
    for i in [1..range] do
        fp := PolynomialRing(GF(p), 2) ! f;
        if Degree(fp) ne 0 then
            Cp := Curve(AffineSpace(CoefficientRing(Parent(fp)), 2), [fp]);
            if #SingularPoints(Cp) gt #SingularPoints(C) then
                BadPrimes := Append(BadPrimes, p);
            end if;
        else
            if fp eq 0 then
                BadPrimes := Append(BadPrimes, p);
            end if;
        end if;
        p := NextPrime(p);
    end for;
    return BadPrimes;
end function;

d := 4;
S := [2, 0];
P := ProjectivePlane(Rationals());
C := RandomPlaneCurve(d, S, P);
f := CurveToIntegralPolynomial(AffinePatch(C, 1));
BadPrimeComputer(f);

